p2 <- ggplot(data = df, aes(x=euclidean_distance,y=num_pairs, fill = as.factor(euclidean_distance))) +
geom_bar(stat= "identity") +
scale_fill_brewer(palette = "Paired") +
theme(legend.position = "none") +
geom_text(aes(label=num_pairs), position = position_dodge(width = .9), vjust=-.25) +
ylim(0, 1.2 * max(pairs)) +
scale_x_continuous(breaks = df$euclidean_distance)
grid.arrange(p1,p2,ncol =1)
}
geoda_correlogram2(10, 4823.3, clev.points$sale_price, coords)
geoda_correlogram2 <- function(lag.order, distance, var,coords){
# creating vectors to store autocorrelation values and number of pairs
pairs <- rep(NA, lag.order)
spat_auto_cor <- rep(NA, lag.order)
#loop to calculate number of pairs for each lag order
for(i in 1:lag.order) {
nb <- dnearneigh(coords, (i-1) * distance, i * distance)
pairs[i] <- sum(card(nb)) / 2
}
# Main difference between 1st geoda_correlogram function is this section
nb1 <- dnearneigh(coords, 0 , distance)
sp <- sp.correlogram(nb1, var, order = lag.order, method = "I", style = "W", randomisation = FALSE, spChk = NULL, zero.policy = TRUE)
########
df <- data.frame(lag = 1:lag.order, num_pairs = pairs, auto_corr = sp$res[,1])
df$euclidean_distance <- df$lag * round(distance, digits = 0)
# Making plots
p1 <- ggplot(data = df, aes(x = euclidean_distance,y = auto_corr)) +
geom_point() +
geom_smooth(col = "purple", se = FALSE) +
geom_hline(yintercept = 0) +
ylim(-1,1)  +
scale_x_continuous(breaks = df$euclidean_distance)
p2 <- ggplot(data = df, aes(x=euclidean_distance,y=num_pairs, fill = as.factor(euclidean_distance))) +
geom_bar(stat= "identity") +
scale_fill_brewer(palette = "Paired") +
theme(legend.position = "none") +
geom_text(aes(label=num_pairs), position = position_dodge(width = .9), vjust=-.25) +
ylim(0, 1.2 * max(pairs)) +
scale_x_continuous(breaks = df$euclidean_distance)
grid.arrange(p1,p2,ncol =1)
}
geoda_correlogram2(10, 4823.3, clev.points$sale_price, coords)
geoda_correlogram2 <- function(lag.order, distance, var,coords){
# creating vectors to store autocorrelation values and number of pairs
pairs <- rep(NA, lag.order)
spat_auto_cor <- rep(NA, lag.order)
#loop to calculate number of pairs for each lag order
for(i in 1:lag.order) {
nb <- dnearneigh(coords, (i-1) * distance, i * distance)
pairs[i] <- sum(card(nb)) / 2
}
# Main difference between 1st geoda_correlogram function is this section
nb1 <- dnearneigh(coords, 0 , distance)
sp <- sp.correlogram(nb1, var, order = lag.order, method = "I", style = "W", randomisation = FALSE, spChk = NULL, zero.policy = TRUE)
########
df <- data.frame(lag = 1:lag.order, num_pairs = pairs, auto_corr = sp$res[,1])
df$euclidean_distance <- df$lag * round(distance, digits = 0)
# Making plots
p1 <- ggplot(data = df, aes(x = euclidean_distance,y = auto_corr)) +
geom_point() +
geom_smooth(col = "purple", se = FALSE) +
geom_hline(yintercept = 0) +
ylim(-1,1)  +
scale_x_continuous(breaks = df$euclidean_distance)
p2 <- ggplot(data = df, aes(x=euclidean_distance,y=num_pairs, fill = as.factor(euclidean_distance))) +
geom_bar(stat= "identity") +
scale_fill_brewer(palette = "Paired") +
theme(legend.position = "none") +
geom_text(aes(label=num_pairs), position = position_dodge(width = .9), vjust=-.25) +
ylim(0, 1.2 * max(pairs)) +
scale_x_continuous(breaks = df$euclidean_distance)
grid.arrange(p1,p2,ncol =1)
}
geoda_correlogram2(10, 4823.3, clev.points$sale_price, coords)
geoda_correlogram2(20, 2000, clev.points$sale_price, coords)
geoda_correlogram(20, 2000, clev.points$sale_price, coords)
geoda_correlogram2(10, 2413.15, clev.points$sale_price, coords)
geoda_correlogram(10, 2413.15, clev.points$sale_price, coords)
geoda_correlogram2(20, 1000, clev.points$sale_price, coords)
geoda_correlogram(20, 1000, clev.points$sale_price, coords)
?geom_smooth
ggplot(data = clev.points, aes(x=standardized_sale_price, y = standardized_lag_sale_price)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
geom_hline(yintercept = 0, lty = 2) +
geom_vline(xintercept = 0, lty = 2) +
xlim(-10,10) +
ylim(-10,10) +
ggtitle("Moran scatter plot sale price")
ggplot(data = clev.points, aes(x=standardized_sale_price, y = standardized_lag_sale_price)) +
geom_point() +
stat_plsmo(span = .2, color = "blue") +
geom_hline(yintercept = 0, lty = 2) +
geom_vline(xintercept = 0, lty = 2) +
xlim(-10,10) +
ylim(-10,10) +
ggtitle("LOWESS smooth of Moran Scatterplot")
ggplot(clev.points, aes(x=standardized_sale_price,y=standardized_lag_sale_price)) +
geom_point(aes(color=bottom_left)) +
geom_smooth(aes(color=bottom_left), method = lm, se = FALSE) +
geom_smooth(method=lm,se = FALSE, color = "black") +
scale_color_manual(values=c("blue","red"))  +
labs(color="Selection") +
geom_hline(yintercept = 0, lty = 2) +
geom_vline(xintercept = 0, lty = 2)
ggplot(clev.points, aes(x=standardized_sale_price,y=standardized_lag_sale_price)) +
geom_point(aes(color=bottom_left)) +
geom_smooth(aes(color=bottom_left), method = lm, se = FALSE) +
geom_smooth(method=lm,se = FALSE, color = "black") +
scale_color_manual(values=c("blue","red"))  +
labs(color="Selection") +
geom_hline(yintercept = 0, lty = 2) +
geom_vline(xintercept = 0, lty = 2) +
ggtitle("Chow test Moran Scatterplot")
knitr::opts_chunk$set(echo = TRUE)
library(tmap)
library(sf)
library(spdep)
library(ggplot2)
library(deldir)
library(sp)
library(purrr)
library(geodaData)
clev.points <- geodaData::clev_pts
plot(clev.points)
tmap_mode("view")
tm_shape(clev.points) +
tm_dots()
tmap_mode("plot")
coords <- cbind(clev.points$x,clev.points$y)
knn1 <- knearneigh(coords)
str(knn1)
k1 <- knn2nb(knn1)
critical.threshold <- max(unlist(nbdists(k1,coords)))
critical.threshold
nb.dist.band <- dnearneigh(coords, 0, critical.threshold)
summary(nb.dist.band)
dist.band.card <- card(nb.dist.band)
dist.band.card
ggplot() +
geom_histogram(aes(x=dist.band.card)) +
xlab("Number of Neighbors")
plot(nb.dist.band, coords, lwd=.2, col="blue", cex = .5)
dist.band.iso <- dnearneigh(coords, 0, 1500)
iso.card <- card(dist.band.iso)
ggplot() +
geom_histogram(aes(x=iso.card)) +
xlab("Number of Neighbors")
plot(dist.band.iso, coords, lwd=.2, col="blue", cex = .5)
k6 <- knn2nb(knearneigh(coords, k = 6))
k6.card <- card(k6)
ggplot() +
geom_histogram(aes(x=k6.card)) +
xlab("Number of Neighbors")
k6.card <- card(k6)
ggplot() +
geom_histogram(aes(x=k6.card)) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), bins = 1) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), bins = 2) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), bins = 10) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), bins = 30) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), bins = 50) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), bins = 0) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), binwidth = 1) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), binwidth = 2) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), binwidth = .5) +
xlab("Number of Neighbors")
ggplot() +
geom_histogram(aes(x=k6.card), binwidth = .01) +
xlab("Number of Neighbors")
plot(k6, coords, lwd=.2, col="blue", cex = .5)
vtess <- deldir(clev.points$x, clev.points$y)
plot(vtess, wlines="tess", wpoints="none",
lty=1)
voronoipolygons = function(thiess) {
w = tile.list(thiess)
polys = vector(mode='list', length=length(w))
for (i in seq(along=polys)) {
pcrds = cbind(w[[i]]$x, w[[i]]$y)
pcrds = rbind(pcrds, pcrds[1,])
polys[[i]] = Polygons(list(Polygon(pcrds)), ID=as.character(i))
}
SP = SpatialPolygons(polys)
voronoi = SpatialPolygonsDataFrame(SP, data=data.frame(dummy = seq(length(SP)), row.names=sapply(slot(SP, 'polygons'),
function(x) slot(x, 'ID'))))
}
v <- voronoipolygons(vtess)
plot(v)
vtess.sf <- st_as_sf(v)
plot(vtess.sf$geometry)
st_queen <- function(a, b = a) st_relate(a, b, pattern = "F***T****")
queen.sgbp <- st_queen(vtess.sf)
as.nb.sgbp <- function(x, ...) {
attrs <- attributes(x)
x <- lapply(x, function(i) { if(length(i) == 0L) 0L else i } )
attributes(x) <- attrs
class(x) <- "nb"
x
}
queen.nb <- as.nb.sgbp(queen.sgbp)
queen.nb.card <- card(queen.nb)
ggplot() +
geom_histogram(aes(x=queen.nb.card)) +
xlab("Number of Neighbors")
summary(queen.nb)
plot(queen.nb,coords, lwd=.2, col="blue", cex = .5)
us.bound <- geodaData::ncovr
latitude <- map_dbl(us.bound$geometry, ~st_centroid(.x)[[1]])
longitude <- map_dbl(us.bound$geometry, ~st_centroid(.x)[[2]])
center.coords <- cbind(latitude,longitude)
k.poly <- knn2nb(knearneigh(center.coords, longlat = TRUE))
critical.threshold.poly <- max(unlist(nbdists(k.poly,center.coords, longlat = TRUE)))
nb.dist.band.poly <- dnearneigh(center.coords, 0, critical.threshold.poly, longlat = TRUE)
poly.nb.card <- card(nb.dist.band.poly)
ggplot() +
geom_histogram(aes(x=poly.nb.card)) +
xlab("Number of Neighbors")
class(vtess)
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(spdep)
library(geodaData)
clev.points <- geodaData::clev_pts
coords <- cbind(clev.points$x,clev.points$y)
k1 <- knn2nb(knearneigh(coords))
critical.threshold <- max(unlist(nbdists(k1,coords)))
critical.threshold
nb.dist.band <- dnearneigh(coords, 0, critical.threshold)
nb.dist.band <- dnearneigh(coords, 0, critical.threshold)
distances <- nbdists(nb.dist.band,coords)
distances[1]
invd1 <- lapply(distances, function(x) (1/x))
length(invd1)
invd1[1]
invd1a <- lapply(distances, function(x) (1/(x/100)))
invd1a[1]
invd.weights <- nb2listw(nb.dist.band,glist = invd1a,style = "B")
summary(invd.weights)
invd.weights$weights[1]
plot(invd.weights, coords, lwd=.2, col="blue", cex = .5)
k6 <- knn2nb(knearneigh(coords, k = 6))
str(k6)
k.distances <- nbdists(k6, coords)
invd2a <- lapply(k.distances, function(x) (1/(x/100)))
invd2a[1]
invd.weights.knn <- nb2listw(k6,glist = invd2a,style = "B")
invd.weights.knn$weights[1]
kernal.nb <- dnearneigh(coords, 0, critical.threshold)
include.self(kernal.nb)
kernal.nb[[2]]
str(kernal.nb)
kernalw.distances <- nbdists(kernal.nb, coords)
kernalw.distances[1]
uniform <- lapply(kernalw.distances, function(x) x*0 + .5)
uniform[1]
uniform.weights <- nb2listw(kernal.nb,glist = uniform,style = "B")
triangular <- lapply(kernalw.distances, function(x) 1- abs((x/critical.threshold)))
triangular[1]
triang.weights <- nb2listw(kernal.nb,glist = triangular,style = "B")
triang.weights$weights[1]
epanechnikov <- lapply(kernalw.distances, function(x) .75*(1-(x/critical.threshold)^2))
epanechnikov[1]
epan.weights <- nb2listw(kernal.nb,glist = epanechnikov,style = "B")
epan.weights$weights[1]
quartic <- lapply(kernalw.distances, function(x) (15/16)*(1-(x/critical.threshold)^2)^2)
quartic[1]
quartic.weights <- nb2listw(kernal.nb,glist = quartic,style = "B")
quartic.weights$weights[1]
gaussian.w <- lapply(kernalw.distances, function(x) sqrt(2*pi)*exp((-(x/critical.threshold)^2)/2))
gaussian.w[1]
gaussian.weights <- nb2listw(kernal.nb,glist = gaussian.w,style = "B")
gaussian.weights$weights[1]
k.distances1 <- k.distances
for (i in 1:length(k.distances1)){
bandwidth <- max(k.distances1[[i]])
new_row <- 1- abs(k.distances1[[i]] / bandwidth)
k.distances1[[i]] <- new_row
}
k.distances1[[1]]
k7 <- knn2nb(knearneigh(coords, k = 7))
k7.distances <- nbdists(k7, coords)
k.distances2 <- k.distances
for (i in 1:length(k.distances)){
maxk6 <- max(k.distances2[[i]])
maxk7 <- max(k7.distances[[i]])
bandwidth <- (maxk6 + maxk7) /2
new_row <- 1- abs(k.distances2[[i]] / bandwidth)
k.distances2[[i]] <- new_row
}
k.distances2[[1]]
var.band.weights <- nb2listw(k6,glist = k.distances2,style = "B")
var.band.weights$weights[[1]]
B <- as(var.band.weights, "RsparseMatrix")
str(B)
diag(B) <- 1
var.band.w2 <- mat2listw(as(B, "dgTMatrix"))
str(var.band.w2$weights)
var.band.w2$neighbours
var.band.weights$neighbours
summary(var.band.w2)
plot(var.band.w2, coords, lwd=.2, col="blue", cex = .5)
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(spdep)
library(tmap)
library(ggplot2)
library(GGally)
library(broom)
library(knitr)
library(tidyverse)
?ggparcoord
clev.points <- geodaData::clev_pts
# getting coordinates
coords <- cbind(clev.points$x,clev.points$y)
# creating neighbors list
k6 <- knn2nb(knearneigh(coords, k = 6))
# converting to weights structure from neighbors list
k6.weights1 <- nb2listw(k6)
k6.weights1$weights[[1]]
lag1 <- lag.listw(k6.weights1, clev.points$sale_price)
df <- data.frame(sale_price = clev.points$sale_price, lag1)
kable(head(df))
nb1 <- k6[[1]]
nb1 <- clev.points$sale_price[nb1]
nb1
summary(clev.points$sale_price)
summary(lag1)
sd(clev.points$sale_price)
sd(lag1)
sale.price <- clev.points$sale_price
pcp.vars <- cbind(sale.price,lag1)
ggparcoord(data = pcp.vars,scale ="globalminmax")
sale.price <- clev.points$sale_price
pcp.vars <- cbind(sale.price,lag1)
ggparcoord(data = pcp.vars,scale ="globalminmax") +
ggtitle("Parallel Coordinate Plot")
lag2 <- lag.listw(k6.weights2, clev.points$sale_price)
library(sf)
library(spdep)
library(tmap)
library(ggplot2)
library(GGally)
library(broom)
library(knitr)
library(tidyverse)
library(purrr)
clev.points <- geodaData::clev_pts
# getting coordinates
coords <- cbind(clev.points$x,clev.points$y)
# creating neighbors list
k6 <- knn2nb(knearneigh(coords, k = 6))
# converting to weights structure from neighbors list
k6.weights1 <- nb2listw(k6)
k6.weights1$weights[[1]]
lag1 <- lag.listw(k6.weights1, clev.points$sale_price)
df <- data.frame(sale_price = clev.points$sale_price, lag1)
kable(head(df))
nb1 <- k6[[1]]
nb1 <- clev.points$sale_price[nb1]
nb1
summary(clev.points$sale_price)
summary(lag1)
sd(clev.points$sale_price)
sd(lag1)
sale.price <- clev.points$sale_price
pcp.vars <- cbind(sale.price,lag1)
ggparcoord(data = pcp.vars,scale ="globalminmax") +
ggtitle("Parallel Coordinate Plot")
binary.weights <- lapply(k6, function(x) 0*x + 1)
k6.weights2 <- nb2listw(k6, glist = binary.weights, style = "B")
lag2 <- lag.listw(k6.weights2, clev.points$sale_price)
df <- df %>% mutate(lag2 = lag2)
kable(head(df))
180+32-58.5
setwd("~/GIS3")
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(tidyverse)
library(spData)
us_states <- spData::us_states
us_states <- spData::us_states
border_length <- us_states %>%
st_cast("MULTILINESTRING") %>%
st_length()
length_table <- data_frame(name = us_states$NAME, border_length = border_length) %>%
arrange(desc(border_length))
View(length_table)
us_states <- spData::us_states
border_length <- us_states %>%
st_cast("MULTILINESTRING") %>%
st_length()
length_table <- tibble(name = us_states$NAME, border_length = border_length) %>%
arrange(desc(border_length))
length_table
length_table[c(1,48,49),]
world <- spData::world
world <- spData::world
anti_world <- world$geom * c(-1,1)
plot(anti_world)
world <- spData::world
anti_world <- world$geom * c(-1,-1)
plot(anti_world)
library(rsocrata)
install.packages("RSocrata")
library(RSocrata)
crimes <- read.socrata("https://data.cityofchicago.org/resource/x2n5-8w5q.csv")
chicago <- st_read("https://data.cityofchicago.org/resource/igwz-8jzy.geojson)
chicago <- st_read("https://data.cityofchicago.org/resource/igwz-8jzy.geojson")
View(crimes)
plot(chicago$geometry)
unique(crimes$X_primary_decsription)
homicides <- crimes %>% filter(X_primary_decsription == "HOMICIDE")
tm_shape(chicago) +
tm_borders() +
tm_shape(homicides) +
tm_dots()
library(tmap)
tm_shape(chicago) +
tm_borders() +
tm_shape(homicides) +
tm_dots()
st_as_sf
?st_as_sf
?st_point
View(homicides)
st_point(homicides$latitude,homicides$longitude)
st_point(homicides$latitude,homicides$longitude)
st_point(cbind(homicides$latitude,homicides$longitude))
point_mat <- cbind(homicides$latitude,homicides$longitude)
coords <- cbind(homicides$latitude,homicides$longitude)
homicide_points <- st_as_sf(coords)
homicide_points <- st_as_sf(homicides, coords = coords)
coords <- cbind(homicides$latitude,homicides$longitude)
homicide_points <- st_as_sf(homicides, coords = coords)
homicide_points <- st_as_sf(homicides, coords = c("latitude","longitude"))
tm_shape(chicago) +
tm_borders() +
tm_shape(homicide_points) +
tm_dots(col = "red")
coords <- cbind(homicides$latitude,homicides$longitude)
homicide_points <- st_as_sf(homicides, coords = c("longitude","latitude"))
tm_shape(chicago) +
tm_borders() +
tm_shape(homicide_points) +
tm_dots(col = "red")
tmap_mode("view")
tm_shape(chicago) +
tm_borders() +
tm_shape(homicide_points) +
tm_dots(col = "red")
comm.points <- st_join(homicide_points,chicago["area_num_1"])
st_crs(chicago)
st_crs(chicago)
st_crs(homicide_points)
st_crs(homicide_points) <- 4326
comm.points <- st_join(homicide_points,chicago["area_num_1"])
comm.points <- st_join(homicide_points,chicago["area_num_1"])
comm.points$area_num_1 <- as.integer(comm.points$area_num_1)
chicago$area_num_1 <- as.integer(chicago$area_num_1)
library(knitr)
st_geometry(comm.points) <- NULL
homicide.cnts <- comm.points %>% count(area_num_1)
kable(head(homicide.cnts))
homicide.cnts <- homicide.cnts %>% rename(comm = area_num_1, homicide_count = n)
kable(head(homicide.cnts))
chicago <- left_join(chicago,homicide.cnts, by = c("area_num_1" = "comm"))
tm_shape(chicago) +
tm_fill("homicide_count")
tm_shape(chicago) +
tm_fill("homicide_count", style = "quantile", paltte = "-RdBu") +
tm_borders()
tm_shape(chicago) +
tm_fill("homicide_count", style = "quantile", palette = "-RdBu") +
tm_borders()
tm_shape(chicago) +
tm_fill("homicide_count", style = "quantile", palette = c("blue","red")) +
tm_borders()
tm_shape(chicago) +
tm_fill("homicide_count", style = "quantile", palette = c("blue","white","red")) +
tm_borders()
chicago$homicide_count
chicago$homicide_count[is.na(chicago$homicide_count)] <- 0
tm_shape(chicago) +
tm_fill("homicide_count", style = "quantile", palette = c("blue","white","red")) +
tm_borders()
library(ggplot2)
ggplot(chicago, aes(x=homicide_count)) +
geom_histogram()
ggplot(chicago, aes(x=homicide_count)) +
geom_density()
tm_shape(chicago) +
tm_borders() +
tm_shape(homicide_points) +
tm_dots(col = "red")
